%!TEX root = ./m_main.tex

\chapter{Модель жизнедеятельности процесса и алгоритм построения графа действий}

\section{Основные понятия}

\subsection{Введение}

Задача данного документа --- это формализация задачи восстановления дерева процессов в Linux. Перед тем как вводить основные понятия, неформально опишем задачу восстановления:

\underline{Задача восстановления дерева процессов в Linux} --- это задача поиска и исполнения последовательности действий, которые, будучи исполненными, приведут исходных <<пустой>> процесс в состояние целевого дерева процессов. Дополнительное ограничение: действия должны быть выполнимы из пространства пользователя.

Для этой задачи, целевое дерево процессов --- это набор из нескольких процессов, объединённых в дерево отношением родитель-ребёнок. Каждый процесс из этого дерева, в рамках задачи восстановления, есть ни что иное, как статичный набор ресурсов --- снимок состояния. Целевой процесс мы рассматриваем не как развивающийся во времени организм, а просто как состояние этого процесса в определённый момент времени.

Целевое состояние дерева процессов в Linux состоит из множества атрибутов: состояние виртуальной памяти, состояние регистров процессора, идентификатор процесса, группы, сессии и прочие идентификаторы, файловые дескрипторы, которые указывают на открытые файлы, открытые соединения, пространства имён, в которых находится процесс, и так далее. В данном документе мы будем именовать все эти атрибуты понятием <<ресурс>>. Таким образом целевое дерево процессов для нас --- это набор ресурсов. Ниже мы попытаемся формализовать все этим понятия.

Решение задачи восстановления предполагает, что найденная последовательность действий может быть выполнена достаточно быстро, чтобы удовлетворять требованиям живой миграции.

\subsection{Ресурс и процесс}

Для разработки наиболее общего подхода к алгоритму восстановления (генерации команд для восстановления), в плане покрываемых ресурсов, понятие ресурса должно быть достаточно широким.

\begin{defn}
\label{def:resource}
\emph{Ресурс} --- $r$ --- некоторая структура в ядре ОС, которая так или иначе используются \emph{процессом} и операционной системой. 
Такая структура --- это абстрактное понятие само по себе, она может представлять из себя реальный экземпляр сишной структуры в ядре, но можеть быть чем-то менее осязаемым.
\end{defn}

Ресурсы существуют не просто так, а как описывается в определении, они используются процессами. Обычно, процесс не может взаимодействовать с ресурсом, как со структурой/объектом в ядре, напрямую. Вместо этого у процесса есть некоторый интерфейс к ресурсу.

\begin{defn}
\emph{Интерфейс к ресурсу} --- \textit{handle} --- это объект, через который процесс получает доступ к ресурсу. Будем обозначать его как $h$.
\end{defn}

Во введении мы неформально говорили, что дерево процессов (и один процесс в частности) --- это набор ресурсов. В терминах определений выше мы будем считать что процесс --- это набор пар $(r, h)$, где $r$ --- ресурс, а $h$ --- интерфейс к ресурсу.

\begin{exmp}
При открытия файла процессом (вызов \texttt{open()}) ядро создаёт объект \texttt{file}, а процессу возвращается файловый дескриптор \texttt{fd}, посредством которого с файлом можно работать. Файловый дескриптор --- это по сути просто число, с помощью которого можно идентифицировать файл. В это случае \emph{ресурс} --- это объект \texttt{file}, а \emph{handle} --- это файловый дескриптор. Из этого примера видно:
\begin{itemize}
	\item Понятие интерфейса к ресурсу нельзя отождествлять с самим ресурсом, т.к. сам ресурс может иметь несколько интерфейсов: два файловых дескриптора указывают на один и тот же файл: $(r, h_1), (r, h_2)$
\end{itemize}
\end{exmp}

\begin{note}
Возможно есть способ обойтись без понятия \emph{handle}. Каким-то образом считать и файловые дескрипторы отдельными ресурсами. Но с этим понятием, пока что, всё лучше укладывается в голове.
\end{note}

Формализуем понятие процесса.

\begin{defn}
\emph{Процесс} --- это множество пар $(r_i, h_i)$ из ресурсов и интерфейсов к ним. Будем обозначать процессы заглавными буквами и писать, например: $P = \xbrace{(r_1, h_1), (r_2, h_2), \ldots, (r_n, h_n)}$
\end{defn}

Факт того, что процесс $P$ владеет ресурсом $r$, к которому получает доступ через \textit{handle} $h$, обозначаем так: $(r, h) \in P$. Также будем писать, что $r \in P$, если $\exists h: (r, h) \in P$.

Будем предполагать далее, что существует множество процессов $\mathcal{P}$, в которое входят всевозможные $P$. Все кванторы ($\exists, \forall$), аргументами которых является процесс, будут обозначать, что процесс этот берётся из $\mathcal{P}$, т.е. $\exists P \Longleftrightarrow \exists P \in \mathcal{P}$.

\begin{defn}
Дерево процессов --- это множество из нескольких процессов: $T = \xbrace{P_1, P_2, \ldots, P_k}$, среди которых выделен корневой процесс $P_{root}$, а для всех остальных процессов верно:
\begin{equation*}
\forall P \in T, P \neq P_{root}: (task, ppid) \in P, \exists P' \in T, (task, pid) \in P'
\end{equation*}
Т.е. родитель любого из процессов, кроме одного ($P_{root}$), находятся в $T$.
\end{defn}

\subsection{Разделяемые и неразделяемые ресурсы}

Ресурсы можно разбить на два множества: те, что могут быть разделены между несколькими процессами и те, что индивидуальны для каждого процесса.

\begin{defn}
\emph{Разделяемый ресурс} --- такой ресурс $r$, что
\begin{equation*}
\exists P_1, P_2 \in \mathcal{P}: P_1 \neq P_2\ \land\ (r, h_1) \in P_1\ \land (r, h_2) \in P_2
\end{equation*}
 То есть возможны таки два процесса, что оба процесса ссылаются на один и тот же ресурс $r$ в ядре, причём не обязательно по одинаковым интерфейсам.
\end{defn}

\emph{Неразделяемый ресурс}, соответственно, тот, что не является разделяемым в рамках определения выше.

К примеру: 
\begin{itemize}
	\item идентификатор процесса (\texttt{pid}) --- неразделяемый ресурс.
	\item значения регистров процесса для потока --- неразделяемый ресурс
	\item открытый файл --- разделяемый ресурс
	\item группа процессов --- разделяемый ресурс
	\item сессия процессов --- разделяемый ресурс
\end{itemize}

\subsection{Наследуемый ресурс}
\label{subsec:inherres}

Как говорилось ранее, между процессами в дереве есть отношение родитель-ребёнок. При создании процесса-ребёнка процессом-родителем в Linux, часть ресурсов может наследоваться ребёнком. Для того, чтобы учитывать это при построении последовательности действий для восстановления, вводим:

\begin{defn}
\label{def:isinherited}
$\isinherited{r}$ --- предикат (свойство ресурса), который принимает значение истины, если ресурс $r$ наследуется процессом-ребёнком от процесса-родителя при создании.
\end{defn}

\subsection{Разделение ресурса между процессами}
\label{subsec:shareres}

Помимо наследования, один ресурс может быть <<передан>> от одного процесса другому уже после того, как эти процессы были созданы. Некоторые ресурсы могут быть разделены таким образом, а некоторые нет. В связи с этим нам понадобится ещё один предикат (свойство ресурса):

\begin{defn}
\label{def:issharable}
$\issharable{r}$ --- предикат, который принимает значение истины, если ресурс $r$ можно <<разделить>> между уже созданными процессами.
\end{defn}

\begin{exmp}
К примеру, процесс в Linux не может переместиться из одной сессии в другую, уже существующую (т.е. сессия не $\issharable{r}$). Но при этом внутри сессии, процесс может перейти в другую группу (разделить группу с каким-то другим процессом). Так же маппинги (Virtual Memory Area) не могут быть переданы между живыми процессами, в то время как файловые дескрипторы можно разделить.
\end{exmp}

Также есть ресурсы с особенной семантикой: например, private mappings --- это, казалось бы, неразделяемый ресурс, который при наследовании, всё же, становится разделяемым из-за механизма Copy On Write.

\begin{note}
Так же отдельного внимания заслуживают \texttt{pid namespace}. Тут я о них просто упоминаю, но механизм перехода в \texttt{pid namesapce} должен быть как-то встроен в модель, описываемую в этом документе: пока я об это не думал. Это частный случай! С ним всё не так красиво будет, скорее всего (но возможно, его можно будет как-то спрятать внутрь конкретной реализации исполнения действия $\crfork{}{}$, о котором см. ниже)
\end{note}

\section{Действия и свойства процесса восстановления}

Во введении мы дали неформальное определение задачи восстановления: поиск (и выполнение) набора действий, которые нужно исполнить для успешного воссоздания целевого дерева. Для формализации этой задачи мы должны понять, из какого множества нам вообще выбирать эти самые <<действия>>.

Ресурсы Linux процесса различны, а значит и их восстановление выполняется по-разному. Т.к. ресурс так или иначе находится в ядре ОС, а из пространства пользователя мы получаем доступ к ядру через системные вызовы (так же существуют специальные файловые системы в духе \texttt{/proc}), то восстановление каждого ресурса --- это последовательность из каких-то системных вызовов. Таким образом, множеством возможных действий, мы можем выбрать множество системных вызовов. Такой подход приведёт к ряду трудностей:
\begin{itemize}
	\item Нет абстракции от деталей восстановления каждого ресурса в каждой его возможной конфигурации, из-за чего построение алгоритмов для восстановления зависимостей между ресурсами и процессами теряется в деталях и становится сложным
	\item Формализация алгоритмов восстановления становится очень трудной из-за огромного количества команд (действий), в них содержащихся
	\item Трудность выделить общий подход (независящий от конкретного типа ресурса) к процессу восстановления
\end{itemize}

Мы попытаемся избежать этих трудностей и внести конкретные детали восстановления каждого из типов ресурсов внутрь более общих, но более простых, с логической точки зрения, команд. Таким образом, в этом разделе мы введём множество команд, достаточно абстрактных, чтобы они могли быть применимы к восстановлению как можно более широкого числа ресурсов. Так же в этом разделе мы введём несколько дополнительных сущностей (свойств), которые помогут нам при генерации (поиске) последовательности действий для восстановления.

На самом деле то, как мы ввели понятие ресурса и дерева процессов, не позволяют нам вводить низкоуровневых команд, т.к. эти понятия были введены довольно общо.

\begin{note}
\label{note:evaluator}
Мы говори про некий список команд, который должен быть исполнен. Кем же он должен исполняться? Т.к. нас интересует решение, работающее в пространстве пользователя, то исполнителями команд должны быть сами процессы (+ процессы помощники, которые не находятся в целевом дереве, но как-то могут помочь его восстановлению): других выходов, как я понимаю, нет.
\end{note}

На этом этапе мы, перед введением множества тех самых действий, можем формализовать задачу восстановления дерева процессов. Будем считать, что действия берутся из множества допустимых действий $\mathcal{A}$.
\begin{defn}
Задача восстановления дерева процессов $T = \xbrace{P_1, P_2, \ldots, P_k}$ --- это задача поиска упорядоченной и конечной последовательности действий $A = \xbracket{a_1, a_2, \ldots, a_n}$, $\forall i: a_i \in \mathcal{A}$, такой, что:
\begin{equation*}
	\xbrace{P_0} \xRightarrow{\qquad A\qquad} \xbrace{P_0} \cup T
\end{equation*}
Тут символ $\xRightarrow{\qquad A\qquad}$ обозначает исполнение команд из последовательности $A$, а $\xbrace{P_0}$ --- это стартовое дерево процессов, которое необходимо в силу того, что кто-то должен начать исполнять команды (см. \hyperref[note:evaluator]{замечание~\ref*{note:evaluator}})
\end{defn}

\subsection{Создание ресурса}

Действия будем стараться вводить исходя из возможностей Linux. Пускай целевое дерево процессов состоит из одного единственного процесса: $P = \xbrace{(r_1, h_1), \ldots, (r_n, h_n)}$. Каким способом процесс $P$ мог завладеть одним из ресурсов $r_i$? Он мог создать его сам: открыть файл, сокет, пайп или создать маппинг.

Таким образом, первое действие, которое мы вводим --- это создание ресурса:

\begin{defn}
\label{def:createact}
Действие создания ресурса --- $\crcreate{P}{r}{\xbracket{h_1, h_2, \ldots, h_k}}$ --- процесс $P$ создаёт ресурс $r$ с интерфейсами $h_i$ к нему. Данное действие исполняется самим процессом $P$ и имеет следующий эффект по отношению к процессу:
\begin{equation*}
	P \xRightarrow{\crcreate{P}{r}{h}} \xbrace{(r, h_1), \ldots, (r, h_k)} \cup P
\end{equation*}
\end{defn}

\begin{note}
Заметим, что в определении мы сделали так, что ресурс создаётся сразу с несколькими интерфейсами. Это связано с тем, что может существуют такие ресурсы, создание которых сопряжено с порождением нескольких интерфейсов к этим ресурсам, но разного рода. Например, pipe или socketpair --- создание этих ресурсов происходит парно. Для ресурса pipe при создании, инициализируется 2 интерфейса: один, для чтения, а другой для записи.

Действия по созданию одной пары $(r, h)$ мы будет записывать просто как: $\crcreate{P}{r}{h}$
\end{note}

\begin{note}
Важно понимать, что ресурс --- это <<структура>> в ядре (см. \hyperref[def:resource]{определение~\ref*{def:resource}}), а значит действие создания ресурса инициирует создание некоторого объекта в ядре. Ядро --- это глобальное хранилище ресурсов, а значит 2 разных действия создания ресурса всегда создают разные ресурсы в ядре:
\begin{equation*}
	\forall \crcreate{P_1}{r_1}{h_1}, \crcreate{P_2}{r_2}{h_2} \in \mathcal{A}: r_1 \neq r_2
\end{equation*}
\end{note}

Предположим, что $(r, h) \in P$, т.е. $P$ ссылается на ресурс $r$. Мы знаем по ранее сказанному, что ресурсы могут быть разделены между процессами, но при решении задачи восстановления дерева процессов, мы не можем знать, в какой последовательности ресурсы передавались друг между другом (вспомни, что есть ресурсы, которые можно <<разделить>> между живыми процессами, см. определение~\ref{def:issharable}). Всё, что видим мы --- это просто снимок состояния дерева. Мы должны как-то понять, какой ресурс каким процессом будет создаваться. Заметим, что если процесс ссылается на ресурс $r$, то это не значит, что он вообще был способен создать этот ресурс самостоятельно. Из-за этого вводим следующий формализм:

\begin{defn}
\label{def:possiblecrtrs}
$\possibleCreators{T}{r}$ --- это множество процессов $P \in T$ такое, что $P$ способен создать ресурс $r$.
\end{defn}

\begin{exmp}
Положим, что мы восстанавливаем дерево $T$.
\begin{itemize}
	\item $r$ --- ресурс, что $type(r) = RegularFile$, тогда $\possibleCreators{T}{r} = T$. (тут вопрос: на деле, файл может открыть только тот процесс, у которого достаточно для этого прав, но в нашей модели мы можем запускать процесс восстановления с наивысшими правами, а потом всё понижать до нужных)

	\item Пусть $T = \xbrace{P_1, P_2, P_3}$. Пускай $(task_1, pid:1) \in P_1, (task_2, pid:2) \in P_2, (task_3, pid:3) \in P_3$. Рассмотрим ресурс $r = pgroup_2$ (группа процессов с id = 2). Тогда верно следующее:
	\begin{itemize}
		\item $\possibleCreators{T}{r} = \xbrace{P_2}$. Вообще говоря, создание группы $2$ может быть осуществлено ещё родителем $P_2$ (допустим это $P_1$): создание ресурса процессом $P_1$ будет заключаться в вызове \texttt{setpgid(2, 2)}, после чего \texttt{setpgid(0, 2)}. Но в этом случае мы изменяем состояние сразу нескольких процессов, что противоречит семантике $\crcreate{}{}$.
		\item $\possibleCreators{\xbrace{P_1}}{r} = \emptyset$, т.к. в одиночку процесс $P_1$ создать этот ресурс не способен (ибо необходим процесс с идентификатором $pid = 2$)
	\end{itemize}
\end{itemize}
\end{exmp}


\subsection{Создание процесса}

Мы бы могли относиться к процессу как к ресурсу, но это больше вносит неоднозначности, нежели чем помогает обобщить процесс восстановления, т.к. всё равно мы логически разделяем ресурсы и процессы. Поэтому к действию создания ресурса добавляется действие создания процесса.

\begin{defn}
\label{def:forkact}
Действие создания процесса --- $\crfork{P_1}{P_2}{pid}$ --- процесс $P_1$ создаёт потомка (процесс) $P_2$ с <<интерфейсом>> (идентификатором процесса) $pid$. Действие имеет следующий эффект:
\begin{equation*}
	\xbrace{P_1} \xRightarrow{\crfork{P_1}{P_2}{pid}} \xbrace{(\text{child task}, pid) \cup P_1, P_2}
\end{equation*}
\end{defn}

При этом процесс, который создаётся ($P_2$) не является пустым. Он может наследовать часть ресурсов своего родителя и может просто получать некоторые ресурсы при рождении, например собственный $pid$. Также у процесса всегда есть родитель: $parent(P)$.

\subsection{Наследование ресурса при рождении}

\hyperref[def:isinherited]{Выше} мы вводили понятие $\isinherited{r}$ --- истина, если $r$ наследуется процессом-ребёнком от родителя при создании. Наследуемые ресурсы должны быть учтены при построении последовательности действий:

После выполнения действия $\crfork{P_1}{P_2}{pid}$ верно, что:
\begin{equation}
\label{eq:inherAtFork} 
	\forall (r, h) \in P_1 \land \isinherited{r}: (r, h) \in P_2.
\end{equation}

\begin{note}
Мы тут считаем, что интерфейс к ресурсу наследуется и сохраняет своё значение.
\end{note}

Выше, в разделах~\ref{subsec:inherres} и \ref{subsec:shareres} обсуждались ресурсы, которые должны разделяться наследованием (private mappings, ...). Мы будем считать, что те ресурсы, что обязательно должны разделяться наследованием не $\issharable{r}$.

\subsection{Разделение ресурса при жизни}

Мы уже описали два действия, позволяющие процессам получать ресурсы: создание ресурса ($\crcreate{}{}{}$) и получение ресурса при рождении ($\crfork{}{}$). Достаточно ли этих команд для того, чтобы описать действиями процесс восстановления любого дерева процессов $T$?

Посмотрим на следующее дерево процессов:

\begin{figure}[ht!]
\centering
\scalebox{.7}{\import{fig/}{procgroupstree1.pdf_tex}}
\begin{caption}{Дерево $T$ из 3 процессов}
$P_1 = \xbrace{(task_1,\ pid: 1), (pgroup_2,\ pgid: 2)}$\\
$P_2 = \xbrace{(task_2,\ pid: 2), (pgroup_2,\ pgid: 2)}$\\
$P_3 = \xbrace{(task_3,\ pid: 3), (pgroup_1,\ pgid: 1)}$
\end{caption}
\end{figure}

В силу специфики Linux, ресурс $pgroup_2$ не может быть создан процессом $P_1$, если процесса $P_2$ ещё не существует (см. пример под определением~\ref{def:possiblecrtrs}). Таким образом нам нужно сначала выполнить действие по созданию процесса $P_2$, после чего уже создавать ресурс $pgroup_2$. Но выполнение действия создания ресурса, по нашему определению, должно затрагивать лишь один процесс, а значит, что за выполнение одного $\crcreate{}{}{}$ ресурс $pgroup_2$ появляется только у одного из процессов (например $P_2$, после чего нам необходимо этот ресурс передать $P_1$.

Таким образом видно, что действий по созданию ресурса и процесса может быть недостаточно (глобальная причина этого заключается в том, как я понимаю, что не каждый процесс может создать произвольный ресурс).

По этим причинам мы вводим ещё одно действие: сделка (разделение ресурса). Введение этого действия оправдывается не только проблемой, описанной выше, но так же и тем, что глупо использовать лишь часть возможностей в Linux по передаче ресурсов между процессами.

\begin{defn}
\label{def:shareact}
Действие разделения ресурса --- $\crshare{P_1}{P_2}{(r, h)}{h'}$ --- процесс $P_1$ разделяет ресурс $(r, h)$ процессу $P_2$ (т.е. у $P_2$ до выполнения действия не было этого ресурса) так, что процесс $P_2$ получает доступ к $r$ посредством \textit{handle} $h'$. Перед выполнением действия верно: $(r, h) \in P_1$. После выполнения действия верно: $(r, h') \in P_2$.
\end{defn}

\subsection{Зависимость между ресурсами}

Одни ресурсы могут зависеть от других. В моём текущем понимании, зависимости между ресурсами проявляются при создании этих ресурсов и этим можно ограничиться. Примеры зависимостей:

\begin{itemize}
	\item Не приватная Virtual Memory Area зависит от того или иного файла, который необходим для создания этого маппинга (\texttt{mmap(...)})
	\item ...
\end{itemize}

Зависимость между ресурсами влияет на порядок выполнения действий при восстановлении. Мы введём обозначение для множества ресурсов, от которых зависит ресурс.

\begin{defn}
\label{def:dependsprop}
$\crdependenices{r, h}$ --- множество ресурсов $(r', h')$, от которых зависит ресурс $r$ (с \textit{handle} $h$).
\end{defn}

\subsection{<<Удаление>> ресурса}

Может случаться так, что процесс из дерева, в целевой своей конфигурации, имеет ресурс $r$, т.е. $(r, h) \in P$. При этом $(q, \_) \in \crdependenices{r, h}$, но $(q, \_) \notin P$. Это значит, что в последовательности действий для восстановления должно фигурировать действие по удаления ресурса $q$ из процесса, после того, как ресурс $r$ был создан. Для того, чтобы обслуживать такую ситуацию, введём действие по удалению ресурса, а точнее пары $(r, h)$.

\begin{defn}
\label{def:removeact}
Действие <<удаления>> ресурса --- $\crremove{P}{r}{h}$ --- процесс $P$ удаляет <<из себя>> пару $(r, h)$. Таким образом верно:
\begin{equation*}
	\xbrace{P_1 \cup \xbrace{(r, h)}} \xRightarrow{\crremove{P_1}{r}{h}} \xbrace{P_1}
\end{equation*}
\end{defn}

Выше, в определении~\ref{def:singleResource}, мы вводили понятие ресурса, который может присутствовать у процесса лишь в одном экземпляре. По сути это значит, что при восстановлении дерева, действие $\crcreate{P}{}{}$ для ресурса этого типа может быть выполнено только один раз. Тут нам приходит на помощь действие $\crremove{}{}{}$: с помощью него можно несколько раз создать такой ресурс, только так, чтобы каждому созданию сопутствовало удаление (возможно, кроме последнего создания). Т.е. если некоторый ресурс $r$ таков, что $\issharable{r} = false$ и при этом в целевом дереве $T$ есть несколько процессов ссылающихся на $r$, то разделяться в процессе восстановления этот ресурс должен методом наследования.

\begin{note}
\textbf{PS}: также, помимо обычных действий ($\crcreate{P}{r}{h}$, $\crshare{P_1}{P_2}{(r, h)}{h'}$) можно вводить их <<временные>> аналоги. Временное действие будет обозначать, что эффект этого действия должен быть устранён по окончании восстановления. Но мы будем использовать подход с $\crremove{P}{r}{h}$
\end{note}

\section{Последовательность действий для восстановления}

Выше мы ввели следующие команды:

\begin{itemize}
	\item $\crcreate{P}{r}{h}$ (опр.~\ref{def:createact})
	\item $\crfork{P_1}{P_2}{pid}$ (опр.~\ref{def:forkact})
	\item $\crshare{P_1}{P_2}{(r, h)}{h'}$ (опр.~\ref{def:shareact})
	\item $\crremove{P_1}{r}{h}$ (опр.~\ref{def:removeact})
\end{itemize}

Все эти команды (со всевозможными комбинациями параметров, соответственно) будут составлять множество всех команд $\mathcal{A}$.

Также мы ввели следующие вспомогательные свойства ресурсов и не только:

\begin{itemize}
	\item $\issharable{r}$ (опр.~\ref{def:issharable})
	\item $\isinherited{r}$ (опр.~\ref{def:isinherited})
	\item $\crdependenices{r, h}$ (опр.~\ref{def:dependsprop})
	\item $\possibleCreators{T}{r}$ (опр.~\ref{def:possiblecrtrs})
\end{itemize}

Теперь наша задача в том, чтобы используя всё это построить решение задачи восстановления, т.е. построить список команд из $\mathcal{A}$ для восстановления.

\textbf{На входе} мы имеем дерево процессов $T = \xbrace{P_1, P_2, \ldots, P_n}$, где каждый из процессов 
\begin{equation*}
P_i = \xbrace{(r_1, h_1), (r_2, h_2), \ldots, (r_{n_i}, h_{n_i})}
\end{equation*}


\subsection{Замыкание ресурсов относительно зависимостей}

Выше говорилось, что одни ресурсы могут зависеть от других (при создании), но при этом если для какого-то процесса $P \in T$ верно, что $(r, h) \in P$ и $(q, \_) \in \crdependenices{(r, h)}$, то может случиться так, что $(q, \_) \notin P$. Поэтому первый шаг, который мы выполним перед генерацией последовательности действий --- это замкнём ресурсы процессов относительно зависимости между ресурсами. В листинге~\ref{code:closedeps} описана процедура замыкания. 

После выполнения замыкания мы имеем новое дерево процессов $T'$ такое, что: для любого процесса $P \in T'$ верно, что если $(r, h) \in P$, то и для любой зависимости $(q, \_) \in \crdependenices{(r, h)} \Rightarrow (q, \_) \in P$.

\begin{listing}[ht!]
\begin{pythoncode}
def close_against_dependencies(T):
    """
    @param T - исходное дерево процессов
    @return новое дерево процессов, той же мощности, что и T, но в котором все процессы 
            замкнуты относительно зависимостей
    """
    new_T = set()

    for P in T:
        new_P = P
        deps = new_P

        while len(deps) > 0:
            next_deps = set()

            for ~$(r, h)$~ in deps:
                next_deps |= ~$\crdependenices{r, h}$~

            new_P |= next_deps
            deps = next_deps

        new_T.add(new_P)

    return new_T
\end{pythoncode}
\caption{Замыкание процессов относительно зависимостей между ресурсами}
\label{code:closedeps}
\end{listing}

Сложность процедуры \texttt{close\_against\_dependencies}: $\bigO{n\cdot|\bigcup\limits_{i = 1}^{n}{P_i}|}$, в смысле числа итераций (выполнения операции объединения множеств \texttt{|=}), где $n$ --- число процессов.

Далее будем решать задачу для нового дерева $T'$, но в конце обязательно перейдём к решению исходной задачи путём добавления нужных действий $\crremove{}{}{}$.

\begin{note}
\label{note:badresourceconfig}
Во время операции замыкания мы добавляем новые ресурсы к процессу. В рамках нашей модели это абсолютно допустимая операция, но всегда ли такое допустимо в настоящем Linux процессе? Думаю, что нет. Проблема в том, что когда мы имеем исходное дерево процессов $T = \xbrace{P_1, P_2, \ldots, P_k}$, то мы можем считать, что оно верно, с точки зрения допустимости конфигураций ресурсов каждого из процессов $P_i$ в Linux, т.к. это дерево мы берём с реального снимка (dump) реального дерева. Но как только мы начинаем искусственно добавлять новые ресурсы, мы уже не можем быть уверены в том, что получаемые конфигурации ресурсов могут реально существовать. Простой пример: допусти, процесс держит <<ресурс>> --- \texttt{VMA(start=0, end=10)} (virtual memory area), а другой его ресурс зависит от \texttt{VMA(start=0, end=5)}. Но два таких маппинга не могут одновременно присутствовать в процессе!
\end{note}

В силу замечания выше введём ещё один вспомогательный предикат:

\begin{defn}
$\canExistAtOnce{r_1, h_1, r_2, h_2}$ --- предикат, возвращающий $True$, если $(r_1, h_1)$ и $(r_2, h_2)$ могут одновременно принадлежать одному и тому же процессу (в один момент времени).
\end{defn}

\begin{note}
Заметим, что данный предикат в том числе позволяет в течение процесса восстановления перемещать один процесс из одной группы в другую, из одной сессии в другую и прочее.
\end{note}

\subsection{Замыкание ресурсов относительно наследования}

Рассмотрим следующую гипотетическую ситуацию: ресурс $r$ разделяется несколькими процессами, при этом $\issharable{r} = false$, а значит ресурс $r$ должен был разделяться между процессами наследованием и никак иначе; при этом, процессы, ссылающиеся на ресурс не образуют дерево (как на рисунке~\ref{fig:inherithole}). 

\begin{figure}[ht!]
\centering
\scalebox{.7}{\import{fig/}{inherithole.pdf_tex}}
\caption{Разделяемый наследованием ресурс, удалённый в нелистовом процессе}
\label{fig:inherithole}
\end{figure}

Случай, который похож на случай с зависимостью, на которую не ссылается процесс. И разрешить проблему можно похожим образом: добавить временно ресурсы в нужный процессы так, чтобы процессы, разделяющие ресурс передаваемый исключительно наследованием, формировали дерево. Конечно, после использования временные ресурсы должны быть удалены.
Процедура замыкания описана в листинге~\ref{code:closeinher}.

\begin{listing}[ht!]
\begin{pythoncode}
def close_against_inheritance(T):
    new_T = copy(T)
    all_resources = get_all_resources_with_handles(new_T)

    for (r, h) in all_resources:
        processes = get_holders(new_T, r, h)  # возвращает множество процессов, 
                                              # ссылающихся на ресурс (r, h)
        top = get_top_process(processes)  # возвращает самый верхний (ближе к корню) процесс

        for P in processes:
            cur_P = parent(P)

            while P != top and cur_P not in processes:
                # значит cur_P не содержит (r, h), т.е. нашли "дырку"
                cur_P.add(r, h)
                cur_P = parent(cur_P)

    return new_T
\end{pythoncode}

\caption{Замыкание относительно наследования}
\label{code:closeinher}
\end{listing}

Асимптотическая сложность данной процедуры:  $\bigO{n\cdot|\bigcup\limits_{i = 1}^{n}{P_i}|}$ (опять же, я тут не учитываю сложности отдельных операций, т.к. их считаю достаточно простыми: все они вкладываются в полиномиальные рамки с лёгкостью). Тут важно увидеть, что внутренний цикл \texttt{while} исполняется суммарно не более \texttt{len(new\_T)} = $n$. А внешний цикл совершает итераций столько, сколько у нас всего ресурсов в объединении всех процессов.

Заметим, что тут мы видим аналогичную проблему, описанную в замечании~\ref{note:badresourceconfig}. Мы будем с этим бороться аналогично, на этапе генерации последовательности команд, используя предикат $\canExistAtOnce{}{}$.

Будем считать, что у нас теперь есть деревья $newT$ и $T$, что $T$ --- целевое, а $newT$ --- целевое, но замкнутое относительно зависимостей и наследования. Будем работать с первым, после чего подкрутим последовательность действий, чтобы удовлетворить исходной задаче. Заметим, что $\canExistAtOnce{r_1, h_1}{r_2, h_2}$ может быть $false$ только если $(r_1, h_1) \in newT \land (r_1, h_1) \notin T$ или $(r_2, h_2) \in newT \land (r_2, h_2) \notin T$ (т.е. хотя бы один из ресурсов $r_1$ или $r_2$ должен быть в $newT$)

\begin{note}
Мы помним, что часть ресурсов у нас при создании процесса-ребёнка наследуются. Может случиться так, что один из наследованных ресурсов $r$ не должен находиться в целевом процессе-ребёнке, а значит он должен быть удалён, причём до создания других ресурсов (желательно), ведь они могут конфликтовать. Такие удаления ($\crremove{}{}{}$) мы добавим в самом конце нашей процедуры построения списка команд в нужное место (сразу после $\crfork{}{}$ процесса-ребёнка) В рамках модели эти ресурсы нам никак не мешают.
\end{note}

\subsection{Добавление ресурса к possibleCreators}

Когда мы вводили определение~\ref{def:possiblecrtrs}, мы заметили, что не каждый процесс может создать определённый ресурс. Например, группа с идентификатором $ID$ может быть создана только процессом с $pid = ID$. Можно представить ситуацию, что процесс $P$ --- единственный, кто может создать ресурс $r$, но при этом мы, на снимке дерева, наблюдаем то, что на $r$ ссылается только $Q \neq P$, а у $P$ этого ресурса вообще нет. Что делать? Такое действительно может произойти, например, с группами процессов: $P_1 = \xbrace{(group 2, gid=1)}, P_2 = \xbrace{(group 2, gid=1)}, P_3 = \xbrace{(group 1, gid=1)}$: такое дерево вполне себе может существовать в Linux, но при это при его восстановлении нам будет необходимо в какой-то момент сделать так, чтобы процесс $P_1$ создал группу $1$.

Для обслуживания таких ситуаций мы сделаем следующее. Ещё немного измени исходное дерево процессов так, чтобы для любого ресурса $r$: $\possibleCreators{T}{r} \cap \resourceHolders{T}{r} \neq \emptyset$.

\begin{listing}
\begin{pythoncode}
def ensure_creators_have_holder(T):
    new_T = copy(T)
    for r in get_all_resources(new_T):
        creators = ~$\possibleCreators{new\_T}{r}$~
        if len(creators) == 0:
           # Наш алгоритм тут возвращает ошибку, пока мы не поддерживаем таких
           # ресурсов, которые не могут быть созданы ни одним из процессов из
           # снимка (такое возможно, опять же, с группами)
           raise ProcessTreeIsNotComplete()
        if len(creators & get_holders(r)) == 0:
            P = top(creators)  # наиболее высокий в дереве процесс)
            P.add(r, construct_handle(P, r))
    return new_T
\end{pythoncode}
\caption{Расширение ресурсов процесса, который ответственен за создание ресурса, но не ссылается на него}
\end{listing}

\subsection{Добавление вспомогательного корневого процесса}

Для того, чтобы у всех процессов целевого дерева процессов существовал родитель, ответственный за его создание, мы добавляем вспомогательный процесс $P_0$, который будет ответственен за создание корня дерева $T$: $parent(root(T)) = P_0$.

Тут нужно подвести итог. Исходно мы имели дерево 
\begin{equation*}
T = \xbrace{P_1, \ldots, P_n}
\end{equation*} 
являющееся допустимым снимком дерева процессов Linux, но после описанных операций добавления временных ресурсов и прочего, мы имеем дерево:
\begin{equation*}
T' = \xbrace{P_0, P_1', \ldots, P_n'}
\end{equation*}
такое, что:

\begin{itemize}
	\item $P_i' \cap P_i = P_i$
	\item $P_0 = root(T') = parent(root(T))$
	\item Для любого ресурса $r \in T'$ верно, что $\possibleCreators{T'}{r} \cap \resourceHolders{T'}{r} \neq \emptyset$
	\item $\forall P' \in T': $ для любой пары $(r, h) \in P'$, верно, что $\crdependenices{r, h} \subset P'$
	\item Для любого ресурса $r \in T'$ такого, что $r$ разделяется только наследованием, т.е. $\isinherited{r} = true \land \issharable{r} = false$ верно, что $\resourceHolders{T'}{r}$ образуют дерево (не лес!) относительно отношения родитель-ребёнок
	\item $\forall i \forall (r, h), (r', h') \in P_i: \canExistAtOnce{r, h}{r', h'} = true$ но при этом, \underline{возможно}, что для какой-то пары ресурсов $(r, h) \in P_i' \cap P_i, (r', h') \in P_i': \canExistAtOnce{r, h}{r', h'} = false$
\end{itemize}

Мы будем обозначать: $P_i \cap P_i' = Tmp_i$

\subsection{Генерация множества действий}

На первом шаге мы сгенерируем множество действий $A$, которые далее соберём в граф, линеаризация (топологическая сортировка) которого и будет ответом на задачу.

\begin{itemize}
	\item $\crfork{}{}$: действие должно присутствовать в $A$ для каждого процесса из дерева. См. листинг~\ref{code:forkacts}.

\begin{listing}[ht!]
\begin{pythoncode}
def get_fork_actions(T):
    acts = set()
    for P in T:
        if P == root(T):
            continue
        acts.add(~$\crfork{parent(P)}{P}{P.pid}$~)
    return acts
\end{pythoncode}
\caption{Добавление действий $\crfork{parent(P)}{P}{P.pid}$ для всех $P \in T \setminus \xbrace{P_0}$}
\label{code:forkacts}
\end{listing}

	\item $\crcreate{}{}{}$: действие должно быть добавлено для каждого ресурса, причём создавать этот ресурс обязан тот процесс, который может это сделать ($P$ из $\possibleCreators{T}{r}$). См. листинг~\ref{code:cracts}.

\begin{listing}[ht!]
\begin{pythoncode}
def get_resource_creator(T, r):
    return top(~$\possibleCreators{T}{r} \cap get\_holders(T, r)$~)

def get_create_actions(T):
    acts = set()
    resources = get_all_resources(T)
    for r in resources:
        creator = get_resource_creator(T, r)
        h = get_creator_handle(creator, r)  # возвращает любой из хэндлов, по
                                            # которому creator ссылается на r, 
                                            # но всегда один!
        acts.add(~$\crcreate{creator}{r}{h}$~)
    return acts
\end{pythoncode}
\caption{Добавление действий создания ресурсов}
\label{code:cracts}
\end{listing}


	\item $\crremove{}{}{}$: Данное действие должно быть добавлено для каждого временного ресурса ($r \in Tmp_i$) в каждом процессе. В отличие от действия создания ресурса данное действие может выполняться несколько раз для одного и того же ресурса, но с разными handle. Генерация показана в листинге~\ref{code:removetmpacts}. Также данное действие должно быть добавлено для всех наследуемых ресурсов, но т.к. на данном этапе мы не знаем конкретной последовательности действий, то мы не можем сказать, какие конкретно ресурсы будут наследоваться, поэтому выполним это последним шагом.  

\begin{listing}[ht!]
\begin{pythoncode}
def get_remove_tmp_acts(T):
    acts = set()
    for P in T:
        tmps = get_tmp_resources(P)  # возвращает множество временных ресурсов
                                     # см. выше $Tmp_i$
        for (r, h) in tmps:
            acts.add(~$\crremove{P}{r}{h}$~)
    return acts
\end{pythoncode}
\caption{Добавление действий удаления временных ресурсов}
\label{code:removetmpacts}
\end{listing}

	\item $\crshare{}{}{}{}$: мы считаем, что если ресурс поддерживает возможность разделения его при жизни (как альтернатива наследованию), то нужно её использовать. Поэтому для каждого ресурса $r$, который $\issharable{r} = true$, мы будем генерировать действия разделения этого ресурса нуждающимся. См. листинг ~\ref{code:shareacts}.

\begin{listing}[ht!]
\begin{pythoncode}
def get_share_acts(T):
    acts = set()
    rs = get_all_resources(T)
    for r in rs:
        creator = get_resource_creator(T, r)
        cr_handle = get_creator_handle(creator, r)
        holders = get_holders(T, r)
        for P in holders:
            handles = get_resource_handles(P, r)  # возвращает список handle'ов на ресурс
                                                  # напр: [h1, h2] значит, что в P есть пары
                                                  # (r, h1), (r, h2)
            
            if not ~$\issharable{r}$~ and (len(handles) > 1 or handles[0] != cr_handle):
                raise NonSharableResourceWithMoreThanOneHandle()

            for h in handles:
                 if h == cr_handle:
                     continue
                 acts.add(~$\crshare{creator}{P}{(r, cr\_handle)}{h}$~)


\end{pythoncode}
\caption{Генерация действий разделения ресурсов}
\label{code:shareacts}
\end{listing}

\begin{note}
Как видим из листинга~\ref{code:shareacts}, если у нас есть какой-то $false = \issharable{r}$ ресурс, с разными хэндлами в разных процессах, то мы падаем с ошибкой. Это, например, может иметь место быть тогда, когда некий private mapping был отнаследован, а потом перемаплен (\texttt{mremap}) в другое место. Пока что такое мы не поддерживаем. Но в будущем можно добавить, например, с помощью дополнительного действия $MoveResource$ или чего-то подобного.
\end{note}

\end{itemize}

\subsection{Отношение предшествования над действиями}

Мы имеем мешок действий, которые должны быть выполнены. Их нужно теперь как-то упорядочить. Простота и атомарность выбранных действий позволяет нам задать частичный порядок (sic!), на основе которого потом построить граф и, если получится, линеаризовать его (если не получится, то значит, что мы столкнулись с деревом, которое наш алгоритм восстановить не в силах, об этом будем говорить подробнее позже).

Предшествование должно строиться по следующим правилам:

\begin{enumerate}[label=(\arabic*)]
	\item \label{precrule:afterfork} Все действия, которые исполняются от лица процесса $P$:
	\begin{equation*}
	    \crcreate{P}{\_}{\_}, \crremove{P}{\_}{\_}, \crfork{P}{\_}{\_}
	\end{equation*}
	или так или иначе задействую процесс $P$: 
	\begin{equation*}
	    \crshare{P}{\_}{\_}{\_}, \crshare{\_}{P}{\_}{\_}
	\end{equation*} 
	должны \underline{выполняться после} того, как было выполнено создание этого процесса: $\crfork{\_}{P}{\_}$

	\item \label{precrule:actswithres} Все действия от лица процесса $P$ с ресурсом $(r, h)$: 
	\begin{equation*}
	    \crremove{P}{r}{h}, \crshare{P}{\_}{(r, h)}{\_}
	\end{equation*}
	должны \underline{выполняться после} действия, эффектом которого было появление ресурса $(r, h)$ у процесса $P$:
	\begin{equation*}
	    \crcreate{P}{r}{h} \lor \crshare{\_}{P}{(r, \_)}{h} \lor \crfork{\_}{P}{\_}
	\end{equation*}
	
	\item \label{precrule:beforeremove} Все действия, в рамках процесса $P$, которые так или иначе используют ресурс $(r, h)$, кроме удаления:
	\begin{equation*}
		\crshare{P}{\_}{(r, h)}{\_}
	\end{equation*} 
	должны быть \underline{выполнены до} $\crremove{P}{r}{h}$, если такое действие в наличии (его может не быть для ресурсов, которые должны присутствовать в финальном дереве) (действие создания будет предшествовать удалению в любом случае из-за предыдущего пункта).

	\item \label{precrule:inherits} Для всех ресурсов $(r, h)$, которые разделяются больше чем одним процессом, т.е. $|get\_holders(T, r, h)| > 1$ и при этом разделяться должны наследованием, т.е. $\isinherited{r} = true \land \issharable{r} = false$, должно выполняться следующее: получение ресурса (это либо создание, либо непосредственно fork) ресурса должно происходить до выполнения $\crfork{}{}{}$ процессов, которые тоже разделяют этот ресурс. 

	То есть, в рамках процесса $P$, если 
	\begin{equation*}
		(r, h) \in P \land |get\_holders(T, r, h)| > 1 \land \issharable{r} = false \land \isinherited{r} = true
	\end{equation*}
	и если $resource\_creator{(r, h)} = P$, то $\crcreate{P}{r}{h}$ должно быть \underline{выполнено до}\\ $\crfork{P}{P'}{pid}$ для любого $P'$, что $(r, h) \in P'$

	\item \label{precrule:dependencies} Также нужно обслужить зависимости между ресурсами. Пускай для процесса $P$ верно, что $(r, h) \in P$ и $(r', h') \in P \land (r', h') \in \crdependenices{r, h}$ и при этом $P$ является создателем ресурса $r'$. Тогда действие получения ресурса $(r, h)$:
	\begin{equation*}
	    \crcreate{P}{r}{h} \lor \crshare{\_}{P}{(r, \_)}{h} \lor \crfork{\_}{P}{\_}
	\end{equation*}
	должно быть \underline{выполнено до}:
	\begin{equation*}
		\crcreate{P}{r'}{h'}
	\end{equation*}

	\item \label{precrule:canexistatonce} Также нужно разобраться с действиями, затрагивающими ресурсы, которые могут конфликтовать ($\canExistAtOnce{}{} = false)$. Тут дела обстоят немного более хитро. Пускай два ресурса $(r, h)$ и $(r', h')$ в рамках одного процесса $P'_i$ конфликтуют. Не умаляя общности мы можем считать, что $(r, h) \in Tmp_i$ (т.к. только <<временные>> ресурсы могут вызывать конфликты, см. замечание~\ref{note:badresourceconfig}). В этом случае нам нужно упорядочить работу с этими ресурсами так, что все действия над $(r, h)$ (включая создание и удаление) происходят раньше, чем все действия над $(r', h')$.

	Очевидно, что нас интересует выполнить действия, связанные с временным ресурсом, который находится в конфликте с постоянным, до действий с постоянным ресурсом.

	Также заметим следующее: пускай ресурс $(r', h')$ --- это ресурс, который процесс получает посредством наследования. Тогда этот ресурс уже существует сразу после создания процесса $P'_i$, а значит у нас уже не получится сделать так, что действия с $(r, h)$ будут выполнены раньше, дабы не вступить в конфликт с $(r', h')$. В этом случае нам необходимо наоборот, поставить работу над $(r', h')$ перед работой над $(r, h)$.


	Так или иначе, исходя из соображений в этом пункте, нам для каждого процесса нужно упорядочить его ресурсы следующим образом:

	\begin{equation*}
	\xbracket{\underbrace{
	          \overbrace{(r_1, h_1), (r_2, h_2), (r_3, h_3), \ldots}^{\text{полученные наследованием}}, 
	          \overbrace{(r_k, h_k), (r_{k+1}, h_{k+1}), \ldots}^{\text{полученные созданием или share}}}_{\text{временные ресурсы}}, 
	          \underbrace{(r_l, h_l),(r_{l+1}, h_{l+1}),\ldots, (r_n, h_n)}_{\text{постоянные (целевые) ресурсы}} }
	\end{equation*}

	А действия над "конфликтующими" ресурсами упорядочивать теперь можно следующим образом: 
	\begin{itemize}
		\item $\forall i < j, \canExistAtOnce{r_i, h_i}{r_j, h_j} = false$: нужно сказать, что действие $\crremove{P}{r_i}{h_i}$ \underline{предшествует} действию, эффектом которого является получение процессом $P$ ресурса $(r_j, h_j)$ (аналогично пункту~\ref{precrule:actswithres}). $i$ будет пробегать только индексы временных ресурсов, а значит действие $\crremove{P}{r_i}{h_i}$ существует для всех таких $i$.

		\item Как видим, если два наследуемых временных ресурса конфликтуют, то восстановление вообще невозможно (т.к. граф будет не ациклическим), ибо любое действия исполняемое процессом должно выполняться после форка этого процесса, поэтому один из ресурсов не может быть удалён до создания исполняющего это действия процесса.
	\end{itemize}
\end{enumerate}

Каждый из пунктов выше описывает правило, по которому одни действия должны исполняться раньше других. Ниже мы опишем все эти правила в псевдокоде, чтобы понять, как реализуется генерация <<рёбер>> предшествования. В листингах с \ref{code:relhelpFirst} по \ref{code:relhelpLast} описаны вспомогательные процедуры.

\begin{listing}[ht!]
\begin{pythoncode}
def get_actions_for_process(all_acts, ~$P$~):
    """
    @param all_acts - множество всех действий
    @param P - интересующий процесс
    """
    acts = set()
    for act in all_acts:
        if act == ~$\crcreate{P}{\_}{\_}$~ or
               act == ~$\crremove{P}{\_}{\_}$~ or
               act == ~$\crshare{P}{\_}{\_}{\_}$~ or
               act == ~$\crshare{\_}{P}{\_}{\_}$~ or
               act == ~$\crfork{P}{\_}{\_}$~:
            acts.add(act)
    return acts
\end{pythoncode}
\caption{Вспомогательная функция, возвращающая только те действия, в которых участвует процесс $P$}
\label{code:relhelpFirst}
\end{listing}

\begin{listing}[ht!]
\begin{pythoncode}
def get_process_fork_act(all_acts, P):
    for act in all_acts:
        if act == ~$\crfork{\_}{P}{\_}$~
            return act
    raise Error("No creator!")
\end{pythoncode}
\caption{Вспомогательная функция, возвращающее действие, эффект которого -- создание процесса $P$}
\end{listing}

\begin{listing}[ht!]
\begin{pythoncode}
def get_proc_obtain_resource_act(all_acts, P, (r, h)):
    if (r, h) not in P:
        raise Error()
    for act in all_acts:
        if act == ~$\crcreate{P}{r}{h}$~ or
               act == ~$\crshare{\_}{P}{(r, \_)}{h}$~:
            return act
    # если с $P$ никто не делится ресурсом и он его не создаёт сам, то
    # остаётся только наследование
    return get_process_fork_act(all_acts, P)
\end{pythoncode}
\caption{Вспомогательная функция, возвращающая действие, благодаря которому процесс $P$ получил ресурс $(r, h)$}
\end{listing}

\begin{listing}[ht!]
\begin{pythoncode}
def get_proc_remove_resource_act(all_acts, P, (r, h)):
    if (r, h) not in P:
        raise Error()
    for act in all_acts:
        if act == ~$\crremove{P}{r}{h}$~
            return act
    # нет действия удаления, значит ресурс и не нужно удалять
    return None 
\end{pythoncode}
\caption{Вспомогательная функция, возвращающее действие, которое удаляет ресурс $(r, h)$ из процесса $P$}
\end{listing}

\begin{listing}[ht!]
\begin{pythoncode}
def get_acts_with_resource(all_acts, P, (r, h)):
    acts = set()
    for act in all_acts:
        # только действие разделения ресурса никак не связано с
        # удалением или созданием ресурса для процесса $P$
        if act == ~$\crshare{P}{\_}{(r,h)}{\_}$~:
            acts.add(act)
    return acts
\end{pythoncode}
\caption{Вспомогательная функция, возвращающее список действий использующих ресурс, но не связанных с его созданием или удалением}
\label{code:relhelpLast}
\end{listing}

Мы будем генерировать <<рёбра>> предшествования: $Preceed(a_1, a_2)$, где $a_1, a_2 \in A$, что обозначает: действие $a_1$ предшествует действию $a_2$.

В листинге~\ref{code:relgenhelper} описана вспомогательная процедура генерации таких рёбер из всех действий одного множества по все действия второго.

В листинге~\ref{code:relgen} описана процедура генерации всех <<рёбер>> предшествования.

\begin{listing}[ht!]
\begin{pythoncode}
def gen_as_preceed_bs(as, bs):
    edges = set()
    for a in as:
        for b in bs:
            edges.add(Preceed(a, b))
    return edges
\end{pythoncode}
\caption{Вспомогательная процедура, генерирующая рёбра предшествования из всех действия из \texttt{as} ко всем действиям из \texttt{bs}}
\label{code:relgenhelper}
\end{listing}

\begin{listing}[ht!]
\begin{pythoncode}
def generate_preceedence_relations(all_acts, T):
    """
    @param all_acts - список всех действий
    @param T - дерево процессов
    """

    edges = set()

    for P in T:
        proc_fork_act = get_process_fork_act(all_acts, P)
        proc_acts = get_actions_for_process(all_acts, P)

        # пункт $\text{\ref{precrule:afterfork}}$
        edges.add(gen_as_preceed_bs([proc_fork_act], proc_acts)

        for (r, h) in P:
            obtain_act = get_proc_obtain_resource_act(proc_acts, P, (r, h))
            remove_act = get_proc_remove_resource_act(proc_acts, P, (r, h))
            resource_acts = get_acts_with_resource(proc_acts, P, (r, h))

            # пункт $\text{\ref{precrule:actswithres}}$ (если remove_act = None, то считаем, что он не добавляется)
            edges.add(gen_as_preceed_bs([obtain_act], 
                                        resource_acts + [remove_act] if remove_act else []))
            # пункт $\text{\ref{precrule:beforeremove}}$
            edges.add(gen_as_preceed_bs(resource_acts, remove_act))

            # пункт $\text{\ref{precrule:inherits}}$
            edges.add(handle_resource_inheritance(T, P, all_acts, (r,h)))

            # пункт $\text{\ref{precrule:dependencies}}$
            edges.add(handle_resource_dependencies(T, P, all_acts, (r, h)))

        # пункт $\text{\ref{precrule:canexistatonce}}$
        edges.add(handle_can_exist_at_once(T, P, all_acts))

    return edges
\end{pythoncode}
\caption{Общая процедура генерации <<рёбер>> предшествования}
\label{code:relgen}
\end{listing}

\begin{listing}[ht!]
\begin{pythoncode}
def handle_resource_inheritance(T, P, all_acts, (r, h)):
    edges = set()
    resource_holders = get_holders(T, (r, h))
    if not ~$\isinherited{r}$~ or ~$\issharable{r}$~ or len(resource_holders) == 1:
        return set()

    # может быть только create или fork
    obtain_act = get_proc_obtain_resource_act(all_acts, P, (r, h))
    if obtain_act != ~$\crcreate{P}{r}{h}$~:
        return set()

    # имеем дело с ресурсом, передаваемым наследованием, который создаётся P
    for H in resource_holders:
        if H == P:
            continue
        fork_act = get_process_fork_act(all_acts, H)
        if fork_act == ~$\crfork{P}{H}{\_}$~:
            edges.add(Precede(obtain_act, fork_act))

    return edges
\end{pythoncode}
\caption{Обработка случая~\ref{precrule:inherits}: добавления рёбер предшествования между действия создания ресурса и создания ребёнка, его наследующего}
\end{listing}

\begin{listing}[ht!]
\begin{pythoncode}
def handle_resource_dependencies(T, P, all_acts, (r, h)):
    # прямая реализация того, что описано в самом пункте
\end{pythoncode}
\caption{Обработка случая~\ref{precrule:dependencies}}
\end{listing}

\begin{listing}[ht!]
\begin{pythoncode}
def handle_can_exist_at_once(T, P, all_acts):
    # прямая реализация того, что описано в самом пункте
\end{pythoncode}
\caption{Обработка случая~\ref{precrule:canexistatonce}}
\end{listing}

\subsection{Граф и сортировка}

В предыдущем пункте мы по сути построили набор вершин и рёбер между ними. Вершины --- это действия, а рёбра между ними --- это <<рёбра>> предшествования. Граф из этого получается естественным образом. Будем обозначать этот граф символом $G$ и называть \emph{графом действий}.

Заключительный этап решения задачи заключается в топологической сортировке этого графа и получения упорядоченного списка действий $\xbracket{a_1, a_2, \ldots, a_{N}}$. Но мы помним, что данный список действий ещё не включает в себя части действий удаления тех ресурсов, которые были созданы предком до создания ребёнка, но при этом ребёнком не используются. Т.е. теперь нам нужно сэмулировать выполнение действий из списка и вставить в нужные места $\crremove{P}{r}{h}$ так, чтобы закрыть лишние ресурсы.

\section{Примеры и гарантии}

TODO: тут будет несколько примеров работы алгоритма, пример дерева, которое алгоритм восстановить не сможет и, возможно, какие-то теоремы про мощность данного подхода

\section{Классификация ресурсов}

TODO: тут будет информация про реальные ресурсы Linux, про то, какими свойствами они обладают в рамках приведённой модели.

\subsection{Идентификаторы процесса}

\begin{table}[ht!]
\centering
\begin{tabular}{|c|c|c|c|}
	\hline
	\textbf{Ресурс} & \textit{\textbf{handle}} & $\isinherited{r}$ &\issharable{r} \\
	\hline
	\hline
	Сам процесс & pid & нет & нет \\
	\hline
	Группа процесса & pgid & да & да, \texttt{setpgid()} \\
	\hline
	Сессия процесса & ssid & да & нет \\
	\hline
	Идентификатор пользователя & uid & да & да, \texttt{setuid()} \\
	\hline
\end{tabular}
\end{table}
