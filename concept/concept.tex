%!TEX program = xelatex
\input{env.tex}
\title{Граф действий для восстановления дерева процессов}
\author{Горбунов Егор Алексеевич}
\date{\today}

\newcommand{\crcreate}[3]{\text{\textit{CreateAction}}(#1, #2, #3)}
% \newcommand{\crcreate}[3]{$#1$ \textit{creates} $#2$ \textit{with} $#3$}
\newcommand{\crshare}[4]{\text{\textit{ShareAction}}(#1, #2, #3, #4)}
\newcommand{\crinher}[2]{\text{\textit{InheritProperty}}(#1, #2)}
\newcommand{\crdepend}[2]{\text{\textit{DependsProperty}}(#1, #2)}
\newcommand{\crremove}[3]{\text{\textit{RemoveAction}}(#1, #2, #3)}
\newcommand{\crfork}[3]{\text{\textit{ForkAction}}(#1, #2, #3)}
\newcommand{\isinherited}[1]{\text{\textit{isInherited}}(#1)}
\newcommand{\issharable}[1]{\text{\textit{isSharable}}(#1)}
\newcommand{\issignleton}[1]{\text{\textit{isSingle}}(#1)}
\newcommand{\possibleCreators}[2]{\text{\textit{possibleCreators}}(#1, #2)}


\begin{document}
\maketitle

\section{Основные понятия}

\subsection{Введение}

Задача данного документа --- это формализация задачи восстановления дерева процессов в Linux. Перед тем как вводить основные понятия, неформально опишем задачу восстановления:

\underline{Задача восстановления дерева процессов в Linux} --- это задача поиска и исполнения последовательности действий, которые, будучи исполненными, приведут исходных <<пустой>> процесс в состояние целевого дерева процессов. Дополнительное ограничение: действия должны быть выполнимы из пространства пользователя.

Для этой задачи, целевое дерево процессов --- это набор из нескольких процессов, объединённых в дерево отношением родитель-ребёнок. Каждый процесс из этого дерева, в рамках задачи восстановления, есть ни что иное, как статичный набор ресурсов --- снимок состояния. Целевой процесс мы рассматриваем не как развивающийся во времени организм, а просто как состояние этого процесса в определённый момент времени.

Целевое состояние дерево процессов в Linux состоит из множества атрибутов: состояние виртуальной памяти, состояние регистров процессора, идентификатор процесса, группы, сессии и прочие идентификаторы, файловые дескрипторы, которые указывают на открытые файлы, открытые соединения, пространства имён, в которых находится процесс, и так далее. В данном документе мы будем именовать все эти атрибуты понятием <<ресурс>>. Таким образом целевое дерево процессов для нас --- это набор ресурсов. Ниже мы попытаемся формализовать все этим понятия.

Решение задачи восстановления предполагает, что найденная последовательность действий может быть выполнена достаточно быстро, чтобы удовлетворять требованиям живой миграции.

\subsection{Ресурс и процесс}

Для разработки наиболее общего подхода к алгоритму восстановления (генерации команд для восстановления), в плане покрываемых ресурсов, понятие ресурса должно быть достаточно широким.

\begin{defn}
\label{def:resource}
\emph{Ресурс} --- $r$ --- некоторая структура в ядре ОС, которая так или иначе используются \emph{процессом} и операционной системой. 
Такая структура --- это абстрактное понятие само по себе, она может представлять из себя реальный экземпляр сишной структуры, но можеть быть чем-то менее осязаемым.
\end{defn}

Ресурсы существуют не просто так, а как описывается в определении, они используются процессами. Обычно, процесс не может взаимодействовать с ресурсом, как со структурой/объектом в ядре, напрямую. Вместо этого у процесса есть некоторый интерфейс к ресурсу.

\begin{defn}
\emph{Интерфейс к ресурсу} --- \textit{handle} --- это объект, через который процесс получает доступ к ресурсу. Будем обозначать его как $h$.
\end{defn}

Во введении мы неформально говорили, что дерево процессов (и один процесс в частности) --- это набор ресурсов. В терминах определений выше мы будем считать что процесс --- это набор пар $(r, h)$, где $r$ --- ресурс, а $h$ --- интерфейс к ресурсу.

\begin{exmp}
При открытия файла процессом (вызов \texttt{open()}) ядро создаёт объект \texttt{file}, а процессу возвращается файловый дескриптор \texttt{fd}, посредством которого с файлом можно работать. Файловый дескриптор --- это по сути просто число, с помощью которого можно идентифицировать файл. В это случае \emph{ресурс} --- это объект \texttt{file}, а \emph{handle} --- это файловый дескриптор. Из этого примера видно:
\begin{itemize}
	\item Понятие интерфейса к ресурсу нельзя отождествлять с самим ресурсом, т.к. сам ресурс может иметь несколько интерфейсов: два файловых дескриптора указывают на один и тот же файл: $(r, h_1), (r, h_2)$
\end{itemize}
\end{exmp}

\begin{note}
Возможно есть способ обойтись без понятия \emph{handle}. Каким-то образом считать и файловые дескрипторы отдельными ресурсами. Но в этим понятием, пока что, всё лучше укладывается в голове.
\end{note}

Формализуем понятие процесса.

\begin{defn}
\emph{Процесс} --- это множество пар $(r_i, h_i)$ из ресурсов и интерфейсов к ним. Будем обозначать процессы заглавными буквами и писать, например: $P = \xbrace{(r_1, h_1), (r_2, h_2), \ldots, (r_n, h_n)}$
\end{defn}

Факт того, что процесс $P$ владеет ресурсом $r$, к которому получает доступ через \textit{handle} $h$, обозначаем так: $(r, h) \in P$. Также будем писать, что $r \in P$, если $\exists h: (r, h) \in P$.

Будем предполагать далее, что существует множество процессов $\mathcal{P}$, в которое входят всевозможные $P$. Все кванторы ($\exists, \forall$), аргументами которых является процесс, будут обозначать, что процесс этот берётся из $\mathcal{P}$, т.е. $\exists P \Longleftrightarrow \exists P \in \mathcal{P}$.

\begin{defn}
Дерево процессов --- это множество из нескольких процессов: $T = \xbrace{P_1, P_2, \ldots, P_k}$, среди которых выделен корневой процесс $P_{root}$, а для всех остальных процессов верно:
\begin{equation*}
\forall P \in T, P \neq P_{root}: (task, ppid) \in P, \exists P' \in T, (task, pid) \in P'
\end{equation*}
Т.е. родитель любого из процессов, кроме одного ($P_{root}$), находятся в $T$.
\end{defn}

\subsection{Разделяемые и неразделяемые ресурсы}

Ресурсы можно разбить на два множества: те, что могут быть разделены между несколькими процессами и те, что индивидуальны для каждого процесса.0

\begin{defn}
\emph{Разделяемый ресурс} --- такой ресурс $r$, что
\begin{equation*}
\exists P_1, P_2 \in \mathcal{P}: P_1 \neq P_2\ \land\ (r, h_1) \in P_1\ \land (r, h_2) \in P_2
\end{equation*}
 То есть возможны таки два процесса, что оба процесса ссылаются на один и тот же ресурс $r$ в ядре
\end{defn}

\emph{Неразделяемый ресурс}, соответственно, тот, что не является разделяемым в рамках определения выше.

К примеру: 
\begin{itemize}
	\item идентификатор процесса (\texttt{pid}) --- неразделяемый ресурс.
	\item значения регистров потока --- неразделяемый ресурс
	\item открытый файл --- разделяемый ресурс
	\item группа процессов --- разделяемый ресурс
	\item сессия процессов --- разделяемый ресурс
\end{itemize}

\subsection{Наследуемый ресурс}
\label{subsec:inherres}

Как говорилось ранее, между процессами в дереве есть отношение родитель-ребёнок. При создании процесса-ребёнка процессом-родителем в Linux, часть ресурсов может наследоваться ребёнком. Для того, чтобы учитывать это при построении последовательности действий для восстановления, вводим:

\begin{defn}
\label{def:isinherited}
$\isinherited{r}$ --- предикат (свойство ресурса), который принимает значение истины, если ресурс $r$ наследуется процессом-ребёнком от процесса-родителя при создании.
\end{defn}

\subsection{Разделение ресурса между процессами}
\label{subsec:shareres}

Помимо наследования, один ресурс может быть <<передан>> от одного процесса другому уже после того, как эти процессы были созданы. Некоторые ресурсы могут быть разделены таким образом, а некоторые нет. В связи с этим нам понадобится ещё один предикат (свойство ресурса):

\begin{defn}
\label{def:issharable}
$\issharable{r}$ --- предикат, который принимает значение истины, если ресурс $r$ можно <<разделить>> между уже созданными процессами.
\end{defn}

\begin{exmp}
К примеру, процесс в Linux не может переместиться из одной сессии в другую, уже существующую (т.е. сессия не $\issharable{r}$). Но при этом внутри сессии, процесс может перейти в другую группу (разделить группу с каким-то другим процессом). Так же маппинги (Virtual Memory Area) не могут быть переданы между процессами, в то время как файловые дескрипторы можно разделить. 
\end{exmp}

Также есть ресурсы с особенной семантикой: например, private mappings --- это, казалось бы, неразделяемый ресурс, который при наследовании, всё же, становится разделяемым из-за механизма Copy On Write.

\begin{note}
Так же отдельного внимания заслуживают \texttt{pid namespace}. Тут я о них просто упоминаю, но механизм перехода в \texttt{pid namesapce} должен быть как-то встроен в модель, описываемую в этом документе: пока я об это не думал. Это частный случай! С ним всё не так красиво будет, скорее всего (но возможно, его можно будет как-то спрятать внутрь конкретной реализации исполнения действия $\crfork{}{}$, о котором см. ниже)
\end{note}

\subsection{Одиночный ресурс}

В силу довольно общего определения термина <<ресурс>> в рамках нашего подхода, приходится эти ресурсы разделять на классы. Выше уже были введены классы ресурсов: $\issharable{r}$ и $\isinherited{r}$. Ещё одним важным свойством некоторых ресурсов является то, что иногда ресурс может существовать в единственном экземпляре. У каждого ресурса есть тип (ведь мы как-то идентифицируем ресурсы!), будь-то файл, группа, идентификатор процесса, сессия, namespace. Таким образом для ресурсов некоторого типа верно, что одновременно два экземпляра этого типа процесс содержать не может.

\begin{defn}
Тип ресурса $r$ --- $type(r)$
\end{defn}

\begin{defn}
\label{def:singleResource}
$\issignleton{r}$ --- предикат, истинный для ресурса $r$, если 
\begin{equation*}
\forall P \in \mathcal{P}, (r, \_) \in P: \forall (r', \_) \in P, r' \neq r: type(r) \neq type(r')
\end{equation*}
Т.е. если процесс $P$ содержит ресурс $r$, то для любого другого ресурса $r'$ этого процесса верно: $type(r') != type(r)$
\end{defn}

\begin{exmp}
Примером такого <<одиночного>> ресурса являются:
\begin{itemize}
	\item Группа процесса
	\item Сессия процесса
	\item Namespace любого типа
	\item Идентификатор процесса
\end{itemize}
В свою очередь открытый файл таким ресурсом не является.
\end{exmp}

\section{Действия и свойства процесса восстановления}

Во введении мы дали неформальное определение задачи восстановления: поиск (и выполнение) набора действий, которые нужно исполнить для успешного воссоздания целевого дерева. Для формализации этой задачи мы должны понять, из какого множества нам вообще выбирать эти самые <<действия>>.

Ресурсы Linux процесса различны, а значит и их восстановление выполняется по-разному. Т.к. ресурс так или иначе находится в ядре ОС, а из пространства пользователя мы получаем доступ к ядру через системные вызовы (так же существуют специальные файловые системы в духе \texttt{/proc}), то восстановление каждого ресурса --- это последовательность из каких-то системных вызовов. Таким образом, множеством возможных действий, мы можем выбрать множество системных вызовов. Такой подход приведёт к ряду трудностей:
\begin{itemize}
	\item Нет абстракции от деталей восстановления каждого ресурса в каждой его возможной конфигурации, из-за чего построение алгоритмов для восстановления зависимостей между ресурсами и процессами теряется в деталях и становится сложным
	\item Формализация алгоритмов восстановления становится очень трудной из-за огромного количества команд (действий), в них содержащихся
	\item Трудность выделить общий подход (независящий от конкретного типа ресурса) к процессу восстановления
\end{itemize}

Мы попытаемся избежать этих трудностей и внести конкретные детали восстановления каждого из типов ресурсов внутрь более общих, но более простых, с логической точки зрения, команд. Таким образом, в этом разделе мы введём множество команд, достаточно абстрактных, чтобы они могли быть применимы к восстановлению как можно более широкого числа ресурсов. Так же в этом разделе мы введём несколько дополнительных сущностей (свойств), которые помогут нам при генерации (поиске) последовательности действий для восстановления.

На самом деле то, как мы ввели понятие ресурса и дерева процессов, не позволяют нам вводить низкоуровневых команд, т.к. эти понятия были введены довольно общо.

\begin{note}
\label{note:evaluator}
Мы говори про некий список команд, который должен быть исполнен. Кем же он должен исполняться? Т.к. нас интересует решение, работающее в пространстве пользователя, то исполнителями команд должны быть сами процессы (+ процессы помощники, которые не находятся в целевом дереве, но как-то могут помочь его восстановлению): других выходов, как я понимаю, нет.
\end{note}

На этом этапе мы, перед введением множества тех самых действий, можем формализовать задачу восстановления дерева процессов. Будем считать, что действия берутся из множества допустимых действий $\mathcal{A}$.
\begin{defn}
Задача восстановления дерева процессов $T = \xbrace{P_1, P_2, \ldots, P_k}$ --- это задача поиска упорядоченной и конечной последовательности действий $A = \xbracket{a_1, a_2, \ldots, a_n}$, $\forall i: a_i \in \mathcal{A}$, такой, что:
\begin{equation*}
	\xbrace{P_0} \xRightarrow{\qquad A\qquad} \xbrace{P_0} \cup T
\end{equation*}
Тут символ $\xRightarrow{\qquad A\qquad}$ обозначает исполнение команд из последовательности $A$, а $\xbrace{P_0}$ --- это стартовое дерево процессов, которое необходимо в силу того, что кто-то должен начать исполнять команды (см. \hyperref[note:evaluator]{замечание~\ref*{note:evaluator}})
\end{defn}

\subsection{Создание ресурса}

Действия будем стараться вводить исходя из возможностей Linux. Пускай целевое дерево процессов состоит из одного единственного процесса: $P = \xbrace{(r_1, h_1), \ldots, (r_n, h_n)}$. Каким способом процесс $P$ мог завладеть одним из ресурсов $r_i$? Он мог создать его сам: открыть файл, сокет, пайп или создать маппинг.

Таким образом, первое действие, которое мы вводим --- это создание ресурса:

\begin{defn}
\label{def:createact}
Действие создания ресурса --- $\crcreate{P}{r}{h}$ --- процесс $P$ создаёт ресурс $r$ с интерфейсом $h$ к нему. Данное действие исполняется самим процессом $P$ и имеет следующий эффект по отношению к процессу:
\begin{equation*}
	P \xRightarrow{\crcreate{P}{r}{h}} (r, h) \cup P
\end{equation*}
\end{defn}

\begin{note}
Важно понимать, что ресурс --- это <<структура>> в ядре (см. \hyperref[def:resource]{определение~\ref*{def:resource}}), а значит действие создания ресурса инициирует создание некоторого объекта в ядре. Ядро --- это глобальное хранилище ресурсов, а значит 2 разных действия создания ресурса всегда создают разные ресурсы в ядре:
\begin{equation*}
	\forall \crcreate{P_1}{r_1}{h_1}, \crcreate{P_2}{r_2}{h_2} \in \mathcal{A}: r_1 \neq r_2
\end{equation*}
\end{note}

Предположим, что $(r, h) \in P$, т.е. $P$ ссылается на ресурс $r$. Мы знаем по ранее сказанному, что ресурсы могут быть разделены между процессами, но при решении задачи восстановления дерева процессов, мы не можем знать, в какой последовательности ресурсы передавались друг между другом (вспомни, что есть ресурсы, которые можно <<разделить>> между живыми процессами, см. определение~\ref{def:issharable}). Всё, что видим мы --- это просто снимок состояния дерева. Мы должны как-то понять, какой ресурс каким процессом будет создаваться. Заметим, что если процесс ссылается на ресурс $r$, то это не значит, что он вообще был способен создать этот ресурс самостоятельно. Из-за этого вводим следующий формализм:

\begin{defn}
\label{def:possiblecrtrs}
$\possibleCreators{T}{r}$ --- это множество процессов $P \in T$ такое, что $P$ способен создать ресурс $r$.
\end{defn}

\begin{exmp}
Положим, что мы восстанавливаем дерево $T$.
\begin{itemize}
	\item $r$ --- ресурс, что $type(r) = RegularFile$, тогда $\possibleCreators{T}{r} = T$. (тут вопрос: на деле, файл может открыть только тот процесс, у которого достаточно для этого прав, но в нашей модели мы можем запускать процесс восстановления с наивысшими правами, а потом всё понижать до нужных)

	\item Пусть $T = \xbrace{P_1, P_2, P_3}$. Пускай $(task_1, pid:1) \in P_1, (task_2, pid:2) \in P_2, (task_3, pid:3) \in P_3$. Рассмотрим ресурс $r = pgroup_2$ (группа процессов с id = 2). Тогда верно следующее:
	\begin{itemize}
		\item $\possibleCreators{T}{r} = \xbrace{P_2}$. Вообще говоря, создание группы $2$ может быть осуществлено ещё родителем $P_2$ (допустим это $P_1$): создание ресурса процессом $P_1$ будет заключаться в вызове \texttt{setpgid(2, 2)}, после чего \texttt{setpgid(0, 2)}. Но в этом случае мы изменяем состояние сразу нескольких процессов, что противоречит семантике $\crcreate{}{}$.
		\item $\possibleCreators{\xbrace{P_1}}{r} = \emptyset$, т.к. в одиночку процесс $P_1$ создать этот ресурс не способен (ибо необходим процесс с идентификатором $pid = 2$)
	\end{itemize}
\end{itemize}
\end{exmp}


\subsection{Создание процесса}

Мы бы могли относиться к процессу как к ресурсу, но это больше вносит неоднозначности, нежели чем помогает обобщить процесс восстановления, т.к. всё равно мы логически разделяем ресурсы и процессы. Поэтому к действию создания ресурса добавляется действие создания процесса.

\begin{defn}
\label{def:forkact}
Действие создания процесса --- $\crfork{P_1}{P_2}{pid}$ --- процесс $P_1$ создаёт потомка (процесс) $P_2$ с <<интерфейсом>> (идентификатором процесса) $pid$. Действие имеет следующий эффект:
\begin{equation*}
	\xbrace{P_1} \xRightarrow{\crfork{P_1}{P_2}{pid}} \xbrace{(\text{child task}, pid) \cup P_1, P_2}
\end{equation*}
\end{defn}

При этом процесс, который создаётся ($P_2$) не является пустым. Он может наследовать часть ресурсов своего родителя и может просто получать некоторые ресурсы при рождении, например собственный $pid$.

\subsection{Наследование ресурса при рождении}

\hyperref[def:isinherited]{Выше} мы вводили понятие $\isinherited{r}$ --- истина, если $r$ наследуется процессом-ребёнком от родителя при создании. Наследуемые ресурсы должны быть учтены при построении последовательности действий:

После выполнения действия $\crfork{P_1}{P_2}{pid}$ верно, что:
\begin{equation}
\label{eq:inherAtFork} 
	\forall (r, h) \in P_1 \land \isinherited{r}: (r, h') \in P_2.
\end{equation}

\begin{note}
Часто $h == h'$ (не всегда ли?) в Linux. Например, открытые файловые дескрипторы процесса-родителя сохраняют свои значения в процессе-ребёнке. Аналогично происходит с адресами начала и конца маппингов и др. Равенство тут понимается не в смысле того, что это одинаковые объекты, а в смысле того, что это одинаковые значения.
\end{note}

Выше, в разделах~\ref{subsec:inherres} и \ref{subsec:shareres} обсуждались ресурсы, которые должны разделяться наследованием (private mappings, ...). Мы будем считать, что те ресурсы, что обязательно должны разделяться наследованием не $\issharable{r}$.

\subsection{Разделение ресурса при жизни}

Мы уже описали два действия, позволяющие процессам получать ресурсы: создание ресурса ($\crcreate{}{}{}$) и получение ресурса при рождении ($\crfork{}{}$). Достаточно ли этих команд для того, чтобы описать действиями процесс восстановления любого дерева процессов $T$?

Посмотрим на следующее дерево процессов:

\begin{figure}[ht!]
\centering
\scalebox{.7}{\import{fig/}{procgroupstree1.pdf_tex}}
\begin{caption}{Дерево $T$ из 3 процессов}
$P_1 = \xbrace{(task_1,\ pid: 1), (pgroup_2,\ pgid: 2)}$\\
$P_2 = \xbrace{(task_2,\ pid: 2), (pgroup_2,\ pgid: 2)}$\\
$P_3 = \xbrace{(task_3,\ pid: 3), (pgroup_1,\ pgid: 1)}$
\end{caption}
\end{figure}

В силу специфики Linux, ресурс $pgroup_2$ не может быть создан процессом $P_1$, если процесса $P_2$ ещё не существует (см. пример под определением~\ref{def:possiblecrtrs}). Таким образом нам нужно сначала выполнить действие по созданию процесса $P_2$, после чего уже создавать ресурс $pgroup_2$. Но выполнение действия создания ресурса, по нашему определению, должно затрагивать лишь один процесс, а значит, что за выполнение одного $\crcreate{}{}{}$ ресурс $pgroup_2$ появляется только у одного из процессов (например $P_2$, после чего нам необходимо этот ресурс передать $P_1$.

Таким образом видно, что действий по созданию ресурса и процесса может быть недостаточно (глобальная причина этого заключается в том, как я понимаю, что не каждый процесс может создать произвольный ресурс).

По этим причинам мы вводим ещё одно действие: сделка (разделение ресурса). Введение этого действия оправдывается не только проблемой, описанной выше, но так же и тем, что глупо использовать лишь часть возможностей в Linux по передаче ресурсов между процессами.

\begin{defn}
\label{def:shareact}
Действие разделения ресурса --- $\crshare{P_1}{P_2}{r}{h}$ --- процесс $P_1$ разделяет ресурс $r$ процессу $P_2$ (т.е. у $P_2$ до выполнения действия не было этого ресурса) так, что процесс $P_2$ получает доступ к $r$ посредством \textit{handle} $r$. После выполнения действия верно: $(r, h) \in P_2$
\end{defn}

\subsection{Зависимость между ресурсами}

Одни ресурсы могут зависеть от других. В моём текущем понимании, зависимости между ресурсами проявляются при создании этих ресурсов и этим можно ограничиться. Примеры зависимостей:

\begin{itemize}
	\item Не приватная Virtual Memory Area зависит от того или иного файла, который необходим для создания этого маппинга (\texttt{mmap(...)})
	\item ...
\end{itemize}

Зависимость между ресурсами влияет на порядок выполнения действий при восстановлении. Введём обозначение для краткого описания того, что один ресурс зависит от другого:

\begin{defn}
\label{def:dependsprop}
$\crdepend{r_1}{r_2}$ --- свойство целевого дерева процессов, гласящее, что ресурс $r_1$ зависит от ресурса $r_2$
\end{defn}

\subsection{<<Удаление>> ресурса}

Может случаться так, что процесс из дерева, в целевой своей конфигурации, имеет ресурс $r$, т.е. $(r, h) \in P$. При этом $\crdepend{r}{q}$, но $(q, \_) \notin P$. Это значит, что в последовательности действий для восстановления должно фигурировать действие по удаления ресурса $q$ из процесса, после того, как ресурс $r$ был создан. Для того, чтобы обслуживать такую ситуацию, введём действие по удалению ресурса, а точнее пары $(r, h)$.

\begin{defn}
\label{def:removeact}
Действие <<удаления>> ресурса --- $\crremove{P}{r}{h}$ --- процесс $P$ удаляет <<из себя>> пару $(r, h)$. Таким образом верно:
\begin{equation*}
	\xbrace{P_1 \cup \xbrace{(r, h)}} \xRightarrow{\crremove{P_1}{r}{h}} \xbrace{P_1}
\end{equation*}
\end{defn}

Выше, в определении~\ref{def:singleResource}, мы вводили понятие ресурса, который может присутствовать у процесса лишь в одном экземпляре. По сути это значит, что при восстановлении дерева, действие $\crcreate{P}{}{}$ для ресурса этого типа может быть выполнено только один раз. Тут нам приходит на помощь действие $\crremove{}{}{}$: с помощью него можно несколько раз создать такой ресурс, только так, чтобы каждому созданию сопутствовало удаление (возможно, кроме последнего создания). Т.е. если некоторый ресурс $r$ таков, что $\issharable{r} = false$ и при этом в целевом дереве $T$ есть несколько процессов ссылающихся на $r$, то разделяться в процессе восстановления этот ресурс должен методом наследования.

\begin{note}
\textbf{PS}: также, помимо обычных действий ($\crcreate{P}{r}{h}$, $\crshare{P_1}{P_2}{r}{h}$) можно вводить их <<временные>> аналоги. Временное действие будет обозначать, что эффект этого действия должен быть устранён по окончании восстановления. Но мы будем использовать подход с $\crremove{P}{r}{h}$
\end{note}

\section{Последовательность действий для восстановления}

Выше мы ввели следующие команды:

\begin{itemize}
	\item $\crcreate{P}{r}{h}$ (опр.~\ref{def:createact})
	\item $\crfork{P_1}{P_2}{pid}$ (опр.~\ref{def:forkact})
	\item $\crshare{P_1}{P_2}{r}{h}$ (опр.~\ref{def:shareact})
	\item $\crremove{P_1}{r}{h}$ (опр.~\ref{def:removeact})
\end{itemize}

Все эти команды (со всевозможными комбинациями параметров, соответственно) будут составлять множество всех команд $\mathcal{A}$.

Также мы ввели следующие вспомогательные свойства ресурсов и не только:

\begin{itemize}
	\item $\issharable{r}$ (опр.~\ref{def:issharable})
	\item $\isinherited{r}$ (опр.~\ref{def:isinherited})
	\item $\crdepend{r_1}{r_2}$ (опр.~\ref{def:dependsprop})
	\item $\possibleCreators{T}{r}$ (опр.~\ref{def:possiblecrtrs})
\end{itemize}

Теперь наша задача в том, чтобы используя всё это построить решение задачи восстановление, т.е. список команд из $\mathcal{A}$ для восстановления.

На входе мы имеем дерево процессов $T = \xbrace{P_1, P_2, \ldots, P_n}$, где каждый из процессов 
\begin{equation*}
P_i = \xbrace{(r_1, h_1), (r_2, h_2), \ldots, (r_{n_i}, h_{n_i})}
\end{equation*}



\section{Классификация ресурсов}

\subsection{Идентификаторы процесса}

\begin{table}[ht!]
\centering
\begin{tabular}{|c|c|c|c|}
	\hline
	\textbf{Ресурс} & \textit{\textbf{handle}} & \textbf{Наследование} & \textbf{Разделение (share)} \\
	\hline
	\hline
	Сам процесс & pid & нет & нет \\
	\hline
	Группа процесса & pgid & да & да, \texttt{setpgid()} \\
	\hline
	Сессия процесса & ssid & да & нет \\
	\hline
	Идентификатор пользователя & uid & да & да, \texttt{setuid()} \\
	\hline
\end{tabular}
\end{table}

\end{document}