\chapter{Введение}


Привет!

\section{О задаче восстановления и сохранения}
 
Основная задача, которая изучается в данном учебном пособии, называется “сохранение и восстановление состояния Linux процессов”. Как мы видим, задача состоит из двух частей: сохранение и восстановление.
 
Сохранение состояния процесса включает в себя сохранение состояния всех ресурсов из которых состоит процесс, а также сохранение состояния окружения, в котором исполняется процесс. Из каких ресурсов состоит типичный Linux процесс? Это регионы виртуальной памяти, открытые файлы, сокеты, устройства, идентификатор процесса, его сессия, группа, идентификатор текущего пользователя и так далее. Что входит в окружение процесса? Это пространства имен процесса (namespaces), контрольные группы (cgroups) и другое плюс их настройки. Стоит заметить, что при сохранении состояния процесса копии открытых им файлов не создаются. Это связано с тем, что файлы и так постоянно хранятся в ФС (файловой системе), а их копии могут занимать очень много места.
 
Что понимается под восстановлением состояния процесса? Это создание всех ресурсов процесса и всех объектов из его окружения, существовавших в момент сохранения, а также восстановление их состояния таким, каким оно было в момент сохранения. Важно, что после восстановления потоки процесса не должны заметить никакого изменения в поведении системных вызовов и своих машинных инструкций. То есть исполнение процесса должно продолжиться так, как если бы он не подвергался операциям сохранения и восстановления своего состояния. Внешние наблюдатели, то есть другие процессы в системе, тоже должны увидеть этот процесс максимально похожим на исходный сохраненный.
 
Уточним, что во время восстановления мы создаем новые экземпляры ресурсов и настраиваем их состояние так, чтобы оно повторяло состояние ресурсов в момент сохранения. При таком подходе внутреннее состояние ресурса, хранящееся, как правило, в ядре, может поменяться. Например, ядерный адрес объекта open file description (struct file в Linux), скорее всего, поменяется у восстановленного open file description, хотя все его состояние, видимое в пространстве пользователя (файловые флаги, смещение и т.д.), будут такими же как и у исходного open file description. В абсолютном большинстве случаев изменение внутреннего состояния ресурса никак не влияет на Linux процессы, т.к. они не могут увидеть это изменение через интерфейс системных вызовов ядра. Одним из исключений для этого правила является системный вызов kcmp.

\section{Применение технологии}

\subsection{Живая миграция}

Живая миграция это перенос работающего приложения с одного узла кластера на другой, выполняемый незаметно для их пользователя. Живую миграцию можно выполнить с помощью сохранения и восстановления процессов приложения. Для этого нужно выполнить сохранение состояния процессов в файлы ФС на исходном узле кластера, скопировать файлы на целевой узел кластера, выполнить восстановление процессов из файлов на целевом узле. Если все эти операции выполняются за незаметное для пользователя время, то миграция является “живой”.
 
\subsection{Обновление ядра без остановки программ}
 
Для ядра Linux регулярно выходят обновления безопасности. При обновлении ядра нередко требуется его перезапуск и остановка всех процессов, работающих в ОС. Если процессы достаточно большие, например, БД занимающие 100 Гб оперативной памяти, то при пропускной способности чтения с диска в 100 Мб/с понадобится 1000 с = 15 мин, чтобы приложения считали свои данные с диска и восстановили свою работу после перезапуска. 15 минут это очень длительная задержка, которой можно избежать при использовании технологии сохранения и восстановления процессов без копирования их памяти. Для этого надо сохранить состояние приложений в оперативной памяти (без копирования страниц памяти приложений, смотрите \url{https://lwn.net/Articles/557046/}), выполнить перезагрузку ядра, выполнить восстановление приложений без копирования их памяти.
 
\subsection{Отложенная отладка}
 
Благодаря технологии сохранения и восстановления процессов мы можем получить “живую” копию приложения для отладки на компьютере разработчика. Без данной технологии мы бы могли анализировать только дамп приложения - статичный снимок его состояния, полученный в определенный момент времени.
 
\subsection{Снимки приложений}
 
Технология сохранения и восстановления процессов позволяет создавать снимки состояний приложения в разные моменты времени и переключаться между ними. 
 
\subsection{Ускорение запуска программ}
 
Некоторые приложения выполняют большой объем работы при своем старте. Технология сохранения и восстановления процессов позволяет сохранить состояние приложения после завершения его инициализации. Вместо запуска приложения выполняется его восстановление в уже проинициализированном состоянии.
 

\section{Возможные реализации}

\subsection{Непрерывное отслеживание и модификация действий процесса}
 
Цель отслеживания и модификации действий процесса - понять какие ресурсы использует процесс и записать информацию о них в файлы ФС во время операции сохранения. Для отслеживания и модификации поведения процесса может использоваться подход проекта DMTCP (http://dmtcp.sourceforge.net/), заключающийся в подмене функций динамических библиотек, используемых процессом. Например, с помощью подмены реализации функции fork, мы запомним какие процессы порождаются наблюдаемым процессом и запишем их состояние в файлы ФС во время операции сохранения. Далее во время восстановления этих процессов нам понадобится создать два новых процесса с теми же pid’ами, которые были у исходных процессов в момент сохранения. Ядро Linux не всегда предоставляет возможность “заказать” pid создаваемого процесса, но и тут мы можем решить проблему с помощью подмены функции динамической библиотеки glibc. Подменим функцию getpid в восстанавливаемых процессах. Подмененные функции getpid обоих процессов будут возвращать pid’ы, которые были у процессов в момент сохранения их состояния. Тогда эти процессы будут считать, что их pid’ы после восстановления не поменялись, хотя их реальные pid’ы с точки зрения других процессов и ядра ОС, скорее всего, будут другими.
 
Основным преимуществом данного подхода является отсутствие необходимости модификации ядра ОС и загрузки ядерных модулей. К недостаткам стоит отнести необходимость в модификации окружения, в котором запускается процесс, постоянные накладные расходы от дополнительных действий в подменённых функциях динамических библиотек, а также принципиальная невозможность сохранить и восстановить состояние ресурса, значительная часть которого хранится в ядре ОС и не имеет интерфейсов для его считывания и модификации. Часто используемым примером такого ресурса является TCP соединение. Внутри ядра хранятся очереди приема, передачи каждого TCP сокета, их sequential number’ы  и другая информация. Системные вызовы ядра Linux (до появления проекта CRIU) не предоставляли возможностей для считывания и установки этих данных и делали сохранение и восстановление TCP соединения невозможным. По этой причине, данный подход позволяет реализовать сохранение и восстановление TCP соединения только между одновременно сохраняемыми процессами, т.к. в этом случае мы можем во время сохранения вычитать все данные из пары сокетов одного соединения и закрыть их, а при восстановлении открыть новую пару TCP сокетов и записать в них все не полученные, но отправленные до старта сохранения данные. В случаях, когда один из процессов на конце соединения не входит в набор сохраняемых процессов, разработчикам приходится реализовывать сохранение и восстановление состояния отдельно для каждого протокола, полагающегося на TCP. Например, требуется отдельный код и набор прокси-объектов для сохранения и восстановления SSH сессий.
 
\subsection{Считывание снимка состояния процесса из ядра}
 
Код сохранения и восстановления процессов встраивается в ядро ОС. Какого-либо вмешательства в работу процесса до начала сохранения его состояния не требуется. Во время сохранения состояния процесса мы останавливаем его, считываем его состояние и сохраняем в файлы ФС. Считывание состояния осуществляется из ядерного кода. Внутри ядра хранится полное состояние процесса, это позволяет сохранить и воспроизвести состояние процесса максимально точно без вмешательства в процесс его исполнения. Тем не менее, данный подход обладает существенными недостатками:
В каждую подсистему ядра требуется добавить набор интерфейсов для создания и удаления объектов, за которые она отвечает. Также требуется добавить набор интерфейсов для  считывания/установки состояния объектов. Данные интерфейсы, по большей части, дублируют интерфейс системных вызовов, который уже реализуется ядром.
В ядро требуется добавить значительный объем кода, координирующий работу большого количества его подсистем во время сохранения и восстановления состояния процесса.
Монолитная конструкция делает процесс отладки сложным. Представим, что в ядре имеется системный вызов \mintinline{c}{sys_checkpoint(int pid, int images_fd, unsigned long flags)}, который сохраняет состояние дерева процессов. Такой системный вызов использовался в проекте OpenVZ, примерно такой же имеется в BLCR. При возникновении ошибки во время работы \mintinline{c}{sys_checkpoint}, ядро сможет вернуть только ее числовой код. По одному числовому значению, обычно, трудно понять, что именно пошло не так. Если же реализовать сохранение состояния дерева процессов в виде последовательности небольших операций, то на каждом шаге исполнения такой последовательности мы гораздо лучше понимаем, что именно мы пытаемся сделать, и что пошло не так.
Перечисленные недостатки привели к невозможности включения кода подобных решений в upstream ядра Linux. Реализации данного подхода в проектах BLCR и OpenVZ находятся в отдельных fork’ах upstream ядра.

\subsection{Считывания снимка состояния процесса системной утилитой}
 
Как и в предыдущем подходе, мы останавливаем процесс и считываем его состояние, но теперь мы делаем это отдельной системной утилитой, использующей только имеющиеся ядерные интерфейсы (системные вызовы, псевдо файловые системы, NETLINK сокеты и т.д.). Примерами реализации такого подхода являются проекты CryoPid и CRIU. Основная проблема такого подхода заключается в том, что имеющихся ядерных интерфейсов недостаточно для считывания и восстановления значительной части состояния процесса.
 
Для преодоления этой проблемы необходимо добавить нужные интерфейсы в ядро, что и было сделано в проекте CRIU. Патчи были приняты в ядро Linux без проблем, так как большая часть изменений заключалась в расширении существующих ядерных интерфейсов. Также в процессе работы над патчами возникали вопросы, касающиеся безопасности. Например, при создании таймера процессом указывается его тип. После этого интерфейс для получения типа таймера не нужен, так как процесс и так его знает. Но для системной утилиты, выполняющей сохранение состояния процесса, этот интерфейс необходим. С точки зрения безопасности, подобное расширение интерфейса дает возможность получить расширенную информацию о состоянии произвольного процесса из любого другого процесса, для чего, как минимум, процесс-читатель состояния должен быть привилегированным.
 
Важным преимуществом реализации восстановления состояния процесса с помощью системной утилиты, работающей в пространстве пользователя является практически полное отсутствие необходимости в добавлении новых ядерных интерфейсов. Ведь раз восстанавливаемый процесс как-то пришел в свое состояние, то он использовал для этого набор существующих системных вызовов, а значит фактической задачей системной утилиты при восстановлении состояния процесса является поиск последовательности системных вызовов (и других операций, таких как чтение-запись памяти процесса), приводящей новый только что созданный процесс в состояние восстанавливаемого процесса. Тем не менее, некоторое расширение ядерных интерфейсов потребуется. Например, нам нужно уметь восстанавливать идентификаторы ресурсов, которые при использовании стандартных системных вызовом генерируются ядром. Также нам нужно уметь восстанавливать часть состояния некоторых ресурсов, хранящуюся в ядре и невидимую в пространстве пользователя. Пример - очереди TCP сокета с данными, ожидающими отправки и получения. Очередь “получения” хранит данные, которые еще не были прочитаны восстанавливаемым процессом, а очередь “отправки” хранит данные записанные в сокет, но еще не полученные на противоположном конце TCP соединения.
 
Как мы видим, данный подход имеет множество практически значимых преимуществ, поэтому далее в нашем учебном курсе мы полностью сфокусируемся на изучении проекта CRIU, который реализует подход к сохранению и восстановлению состояния процессов с использованием системной утилиты. Выбор данного проекта связан с тем, что он совместим с современными версиями ядра Linux (в отличие от CryoPid), активно разрабатывается и используется на практике.
 
\section{Сохранение и восстановление состояния множества процессов}
 
Ранее мы рассматривали задачу сохранения и восстановления состояния отдельно взятого Linux процесса. Такой функциональности нам хватит при работе с достаточно простыми Linux приложениями, состоящими из одного процесса. На практике же нередки случаи, когда приложение состоит из нескольких процессов, имеющих общего родителя (child-parent relation). Каждый ребенок родителя может породить новые процессы приложения, а те в свою очередь другие процессы. В итоге, Linux приложения обычно представляют из себя дерево процессов, связанных отношением родитель-потомок. Кроме того, такая важная в современных облачных технологиях сущность как Linux контейнер, также представляет из себя дерево процессов с корнем, являющимся init процессом всего контейнера. Данные особенности устройства Linux приложений и контейнеров требуют от CRIU поддержки сохранения и восстановления состояния сразу дерева процессов, а не одного процесса.
